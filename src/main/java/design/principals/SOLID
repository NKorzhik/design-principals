1. SINGLE RESPONSIBILITY

    Клас повинен відповідати лише за одну дію.
    Поганий приклад: USER CONTROLLER клас отримує запита на створення, перевіряє валідність данних і зберігає юзера в дані.
    Хороший приклад: USER CONTROLLER приймає запит на створення, в середині містить інстанс класу Валідатор, де прописанийє
    метод перевірки юзера, і окремий інстанс класу Persistence який має метод save user. Таким чином при зміні валідатор,
    буде змінюватися валідація; при зміні сховище, буде змінюватися Persistence.

2. OPEN CLOSED PRINCIPLE

    Відкритий для розширення, але закритий для зміни.
    Хороший приклад: Батьківський клас (абстрактний, добре протестований) повинен бути закритий для модифікації, чайлд
    наслідує батьківський клас і розширює функціонал.
    Поганий приклад: Два окремих класи, які дублюють методи і поля один одного.

3. LISKOV SUBSTITUTION PRINCIPLE

   Головна ідея в тому, щоб чайлд міл легко замінити батька не порушуючи логіку. Краще використовувати інтерфейси, ми
   виносимо спільне в інтерфейси, відповідно порушення ніколи не буде. НЕ можна щоб чайлд змінював поведінку батька.
   Використовуючи інтерфейси у кожного класу буде своя логіка.

4. INTERFACE SEGREGATION

   Не треба засоряти інтерефейси методами, а класи непотрібними методами інтерфейсів. Не можна допустити ситуації, коли
   я імплементую інтерфейс і в реалізованому методі пишу АНСАПОРТЕД.

5. DEPENDENCY INVERSION
    "high level module should not depend on low level module"

    Обидва повинні бути зв'язані за допомогою абстракції.

    Приклад: в нас є клас форматер, у нього є чайлди XML і JSON. І ідея полягає в тому, щоб не самим створювати залежності,
    а отримувати цю залежність звідкись. Тоді, я не створюю інстанс класу в методі, а передаю в метод Форматтер таким чином
    позбавляючи себе на тісний каплінг. Тобто зазвичай методи повинні містити просто бізнес логіку не переймаючись про те,
    які обʼєкти і звʼязки йому треба створювати.